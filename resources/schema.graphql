schema {
  query: Query
  mutation: Mutation
}
type AccessToken {
  accessToken: String!
  scope: String!
  tokenType: String!
}
interface Account {
  id: AccountID!
  name: String!
}
scalar AccountID
type AccountInfo {
  login: String!
  name: String!
  email: String
  avatarUrl: String
  gravatarId: String
}
scalar AccountName
type Accounts {
  "Returns account by its ID"
  byId(accountId: AccountID!): Account
  "Returns account by its name"
  byName(name: String!): Account
}
type Auth {
  githubLogin(code: String!): LoginResponse!
  accountInfo(accessToken: String!): AccountInfo!
}
type BlockInterval {
  start: Multihash!
  end: Multihash!
}
type BlockRef {
  name: String!
  blockHash: Multihash!
}
type DataQueries {
  "Executes a specified query and returns its result"
  query(query: String!, queryDialect: QueryDialect!, dataFormat: DataSliceFormat, schemaFormat: DataSchemaFormat, limit: Int): DataQueryResult!
}
type DataQueryResult {
  schema: DataSchema!
  data: DataSlice!
  limit: Int!
}
type DataSchema {
  format: DataSchemaFormat!
  content: String!
}
enum DataSchemaFormat {
  PARQUET
  PARQUET_JSON
}
type DataSlice {
  format: DataSliceFormat!
  content: String!
  numRecords: Int!
}
enum DataSliceFormat {
  JSON
  JSON_LD
  JSON_SOA
  CSV
}
type DataSliceMetadata {
  logicalHash: Multihash!
  physicalHash: Multihash!
  interval: OffsetInterval!
}
type Dataset {
  "Unique identifier of the dataset"
  id: DatasetID!
  """
  Symbolic name of the dataset.
  Name can change over the dataset's lifetime. For unique identifier use `id()`.
  """
  name: DatasetName!
  "Returns the user or organization that owns this dataset"
  owner: Account!
  "Returns the kind of a dataset (Root or Derivative)"
  kind: DatasetKind!
  "Access to the data of the dataset"
  data: DatasetData!
  "Access to the metadata of the dataset"
  metadata: DatasetMetadata!
  "Creation time of the first metadata block in the chain"
  createdAt: DateTime!
  "Creation time of the most recent metadata block in the chain"
  lastUpdatedAt: DateTime!
}
type DatasetConnection {
  "A shorthand for `edges { node { ... } }`"
  nodes: [Dataset!]!
  "Approximate number of total nodes"
  totalCount: Int
  "Page information"
  pageInfo: PageBasedInfo!
  edges: [DatasetEdge!]!
}
type DatasetData {
  "Total number of records in this dataset"
  numRecordsTotal: Int!
  "An estimated size of data on disk not accounting for replication or caching"
  estimatedSize: Int!
  """
  Returns the specified number of the latest records in the dataset
  This is equivalent to the SQL query: `SELECT * FROM dataset ORDER BY event_time DESC LIMIT N`
  """
  tail(limit: Int, dataFormat: DataSliceFormat, schemaFormat: DataSchemaFormat): DataQueryResult!
}
type DatasetEdge {
  node: Dataset!
}
scalar DatasetID
enum DatasetKind {
  ROOT
  DERIVATIVE
}
type DatasetMetadata {
  "Access to the temporal metadata chain of the dataset"
  chain: MetadataChain!
  "Last recorded watermark"
  currentWatermark: DateTime
  "Latest data schema"
  currentSchema(format: DataSchemaFormat): DataSchema!
  "Current upstream dependencies of a dataset"
  currentUpstreamDependencies: [Dataset!]!
  "Current downstream dependencies of a dataset"
  currentDownstreamDependencies: [Dataset!]!
  currentSummary: String!
  currentTopics: [String!]!
  currentReadme: String!
}
scalar DatasetName
type Datasets {
  "Returns dataset by its ID"
  byId(datasetId: DatasetID!): Dataset
  "Returns dataset by its owner and name"
  byOwnerAndName(accountName: AccountName!, datasetName: DatasetName!): Dataset
  "Returns datasets belonging to the specified account"
  byAccountId(accountId: AccountID!, page: Int, perPage: Int): DatasetConnection!
  "Returns datasets belonging to the specified account"
  byAccountName(accountName: AccountName!, page: Int, perPage: Int): DatasetConnection!
}
"""
Implement the DateTime<Utc> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime
"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point)."
scalar Float
type InputSliceMetadata {
  datasetId: DatasetID!
  blockInterval: BlockInterval
  dataInterval: OffsetInterval
}
type LoginResponse {
  token: AccessToken!
  accountInfo: AccountInfo!
}
type MetadataBlock {
  systemTime: DateTime!
  blockHash: Multihash!
  prevBlockHash: Multihash
  event: MetadataEvent!
}
type MetadataBlockConnection {
  "A shorthand for `edges { node { ... } }`"
  nodes: [MetadataBlock!]!
  "Approximate number of total nodes"
  totalCount: Int
  "Page information"
  pageInfo: PageBasedInfo!
  edges: [MetadataBlockEdge!]!
}
type MetadataBlockEdge {
  node: MetadataBlock!
}
type MetadataChain {
  "Returns all named metadata block references"
  refs: [BlockRef!]!
  "Returns a metadata block corresponding to the specified hash"
  blockByHash(hash: Multihash!): MetadataBlock
  "Iterates all metadata blocks in the reverse chronological order"
  blocks(page: Int, perPage: Int): MetadataBlockConnection!
}
interface MetadataEvent {
  dummy: String!
}
type MetadataEventAddData implements MetadataEvent {
  dummy: String!
  outputData: DataSliceMetadata!
  outputWatermark: DateTime
}
type MetadataEventExecuteQuery implements MetadataEvent {
  dummy: String!
  inputSlices: [InputSliceMetadata!]!
  outputData: DataSliceMetadata
  outputWatermark: DateTime
}
type MetadataEventSeed implements MetadataEvent {
  dummy: String!
  datasetId: DatasetID!
  datasetKind: DatasetKind!
}
type MetadataEventSetPollingSource implements MetadataEvent {
  dummy: String!
}
type MetadataEventSetTransform implements MetadataEvent {
  dummy: String!
}
type MetadataEventSetVocab implements MetadataEvent {
  dummy: String!
}
type MetadataEventSetWatermark implements MetadataEvent {
  dummy: String!
  outputWatermark: DateTime!
}
type MetadataEventUnsupported implements MetadataEvent {
  dummy: String!
}
scalar Multihash
type Mutation {
  auth: Auth!
}
type OffsetInterval {
  start: Int!
  end: Int!
}
type Organization implements Account {
  "Unique and stable identitfier of this organization account"
  id: AccountID!
  "Symbolic account name"
  name: String!
}
type PageBasedInfo {
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "Index of the current page"
  currentPage: Int!
  "Approximate number of total pages assuming number of nodes per page stays the same"
  totalPages: Int
}
type Query {
  "Returns the version of the GQL API"
  apiVersion: String!
  "Dataset-related functionality group"
  datasets: Datasets!
  "Account-related functionality group"
  accounts: Accounts!
  "Search-related functionality group"
  search: Search!
  "Querying and data manipulations"
  data: DataQueries!
}
enum QueryDialect {
  DATA_FUSION
}
type Search {
  "Perform search across all resources"
  query(query: String!, page: Int, perPage: Int): SearchResultConnection!
}
union SearchResult = Dataset
type SearchResultConnection {
  "A shorthand for `edges { node { ... } }`"
  nodes: [SearchResult!]!
  "Approximate number of total nodes"
  totalCount: Int
  "Page information"
  pageInfo: PageBasedInfo!
  edges: [SearchResultEdge!]!
}
type SearchResultEdge {
  node: SearchResult!
}
type User implements Account {
  "Unique and stable identitfier of this user account"
  id: AccountID!
  "Symbolic account name"
  name: String!
}
